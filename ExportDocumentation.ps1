# Export-OSDBuilderDocs.ps1

<#
.SYNOPSIS
Parses a single Markdown file containing OSDBuilder documentation and exports sections to individual files.

.DESCRIPTION
This script reads a Markdown file generated by an AI (like the one provided in the conversation).
It identifies sections based on specific header patterns (e.g., '# Function: FunctionName', '# Module Manifest: FileName.psd1').
Each identified section, including its YAML frontmatter (if present), is saved as a separate Markdown file
in a specified output directory.

.PARAMETER InputMarkdownFile
The full path to the single Markdown file containing all the documentation.

.PARAMETER OutputDirectory
The full path to the directory where individual Markdown files should be saved.
The script will create this directory if it does not exist.

.EXAMPLE
.\Export-OSDBuilderDocs.ps1 -InputMarkdownFile 'C:\Temp\OSDBuilder_All_Docs.md' -OutputDirectory 'C:\Users\Kristian\Desktop\OSDBuilder_Docs_Export'

.NOTES
- Assumes UTF8 encoding for the input and output files.
- Uses Windows line endings (`CRLF`) for output files.
- Requires PowerShell 5.1 or newer (for basic cmdlets).
- Headers must follow the pattern '# SectionType: SectionName' for identification.
#>
[CmdletBinding()]
param(
    [Parameter(Mandatory = $true)]
    [string]$InputMarkdownFile,

    [Parameter(Mandatory = $true)]
    [string]$OutputDirectory
)

# --- Validation ---
if (-not (Test-Path -Path $InputMarkdownFile -PathType Leaf)) {
    Write-Error "Input file not found: $InputMarkdownFile"
    exit 1
}

try {
    # Ensure the output directory exists
    if (-not (Test-Path -Path $OutputDirectory -PathType Container)) {
        New-Item -Path $OutputDirectory -ItemType Directory -Force | Out-Null
        Write-Verbose "Created output directory: $OutputDirectory"
    }
}
catch {
    Write-Error "Failed to create output directory '$OutputDirectory': $($_.Exception.Message)"
    exit 1
}

# --- Read Input File ---
Write-Verbose "Reading input file: $InputMarkdownFile"
try {
    $content = Get-Content -Path $InputMarkdownFile -Raw -Encoding UTF8
}
catch {
    Write-Error "Failed to read input file '$InputMarkdownFile': $($_.Exception.Message)"
    exit 1
}

# --- Parsing Logic for YAML Frontmatter Sections ---
# Regex to find YAML frontmatter blocks and their content
$pattern = "(?ms)^---\s*\n(.*?)\n---\s*\n(.*?)(?=^---\s*\n|\Z)"

$sectionMatches = [regex]::Matches($content, $pattern)

if (-not $sectionMatches.Count) {
    Write-Warning "No sections found matching the expected YAML frontmatter pattern in '$InputMarkdownFile'."
    exit 0
}

Write-Verbose "Found $($sectionMatches.Count) sections."

# --- Export Sections ---
foreach ($match in $sectionMatches) {
    $yaml = $match.Groups[1].Value
    $sectionContent = $match.Groups[2].Value.Trim()

    # Extract 'type' and 'title' from YAML frontmatter
    $type = "Section"
    $title = "Untitled"
    if ($yaml -match "(?m)^type:\s*\"?(.*?)\"?\s*$") {
        $type = $Matches[1].Trim()
    }
    if ($yaml -match "(?m)^title:\s*\"?(.*?)\"?\s*$") {
        $title = $Matches[1].Trim()
    }

    # Sanitize title for filename (remove invalid characters)
    $safeFileName = $title -replace '[\\/:*?"<>|]', '_'
    # Add type to filename for clarity
    $fileName = "$type - $safeFileName.md"
    $outputPath = Join-Path -Path $OutputDirectory -ChildPath $fileName

    Write-Verbose "Exporting '${type}: ${title}' to '$outputPath'"

    try {
        # Write the YAML frontmatter and content to the new file
        Set-Content -Path $outputPath -Value "---`r`n$yaml`r`n---`r`n$sectionContent`r`n" -Encoding UTF8 -Force
    }
    catch {
        Write-Warning "Failed to export section '${type}: ${title}' to '$outputPath': $($_.Exception.Message)"
    }
}

Write-Host "Documentation export complete. Files saved to: $OutputDirectory"